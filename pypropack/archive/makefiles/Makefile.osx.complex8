# Makefile for HLSVD
# Created by the Vespa team
# Copyright & license info for this Makefile (not HLSVD itself) is in the
# Vespa LICENSE file.

# The flag -mmacosx-version-min seems to be ignored when specified as part
# of the compiler command options. The compiler does, however, respect
# the environment variable MACOSX_DEPLOYMENT_TARGET, so one can control the
# min OS X version that way, e.g. export MACOSX_DEPLOYMENT_TARGET=10.9

# OS X hates to link statically and will always link to dynamic version of 
# libraries if it can find them. To force HLSVDPRO to use the static version 
# of libquadmath, we hide the dynamic version from the linker. The 64-bit 
# version of libquadmath is 
# /usr/local/Cellar/gcc@6/6.5.0_5/lib/gcc/6/libquadmath.0.dylib. Rename 
# it from libquadmath.0.dylib to libquadmath.0.dylib.hidden.  I suggest that 
# you undo this rename step after you finish building HLSVDPRO, otherwise you 
# will have a broken GFortran installation.

# BITS can be 32 or 64 and controls the bit mode of the binary.
BITS = 64
ARCH = -m$(BITS) -arch x86_64
OPTIMIZE = -O
DISABLED_WARNINGS = -Wno-unused
WARNINGS = -Wall $(DISABLED_WARNINGS)
FFLAGS = -Wall -g -ffixed-form -fno-second-underscore $(OPTIMIZE) $(ARCH) -fPIC -funroll-loops
# When building LAPACK we force ffpe-trap to be blank (disabled) because
# LAPACK's make file says, "LAPACK is designed to check for and handle these
# cases internally and enabling these traps will likely cause LAPACK to crash."
# ref: https://icl.cs.utk.edu/svn/lapack-dev/lapack/trunk/CMAKE/CheckLAPACKCompilerFlags.cmake
LAPACK_FFLAGS =   -ffpe-trap=  $(FFLAGS)

# These steps will locate the first python installation in your PATH variable.
# I use conda and activate the python that I want before doing my compile, and
# conda ensures that the right path is first in my PATH.
PYDIR := $(shell python -c "from __future__ import print_function;import sys; print(sys.executable)")
PYDIR := $(subst bin/python,,$(PYDIR))
PYMIN := $(shell python -c "from __future__ import print_function;import sys; print(sys.version_info.minor)")
PYMAJ := $(shell python -c "from __future__ import print_function;import sys; print(sys.version_info.major)")
PYVER := $(PYMAJ).$(PYMIN)
PYVER2 := $(PYMAJ)$(PYMIN)

LIBQUADMATHA_DIR := /usr/local/Cellar/gcc@6/6.5.0_5/lib/gcc/6

F2PY_IFLAGS = -I$(PYDIR)lib/python$(PYVER)/site-packages/numpy/core/include -I$(PYDIR)include/python$(PYVER) -I$(PYDIR)include/python$(PYVER)m
F2PY_CFLAGS = -fno-strict-aliasing -I/Users/bsoher/miniconda2/envs/python$(PYVER2)/include -arch x86_64 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes $(F2PY_IFLAGS) 
F2PY_FFLAGS = -Wall -g -ffixed-form -fno-second-underscore -fPIC -O3 -funroll-loops $(F2PY_IFLAGS) 


BIN_DIR = ./bin
DIST_TARGET_DIR = ../../hlsvdpro/
TARGET_LIB_NAME = $(BIN_DIR)/_cpropack.so


all: $(TARGET_LIB_NAME) 


# Create the BIN_DIR if it doesn't exist
$(BIN_DIR): force
	@if (test ! -d $(BIN_DIR)) then \
        mkdir -p $(BIN_DIR); \
	fi


# Pattern rules for turning f2py_Util src files into object files
$(BIN_DIR)/%.o: f2py_Util/%.c
	gcc $(F2PY_CFLAGS) -c $< -o $@

$(BIN_DIR)/%.o: f2py_Util/%.f
	gfortran $(F2PY_FFLAGS) -c $< -o $@
    
# Pattern rule for turning lapack/*.f into object files
$(BIN_DIR)/%.o: Lapack_Util/%.f
	gfortran $(LAPACK_FFLAGS) -c $< -o $@

# Pattern rule for turning HLSVD *.f into object files
$(BIN_DIR)/%.o: %.F
	gfortran $(FFLAGS) -c $< -o $@


# Variables to define lapack object files in the BIN_DIR
LAPACK_SRCS := $(wildcard Lapack_Util/*.f)
LAPACK_OBJS := $(addsuffix .o,$(basename $(notdir $(LAPACK_SRCS))))
LAPACK_OBJS := $(addprefix $(BIN_DIR)/,$(LAPACK_OBJS))

F2PY_SRCS := $(wildcard f2py_Util/*.f)
F2PY_OBJS := $(addsuffix .o,$(basename $(notdir $(F2PY_SRCS))))
F2PY_OBJS := $(addprefix $(BIN_DIR)/,$(F2PY_OBJS))

F2PYC_SRCS := $(wildcard f2py_Util/*.c)
F2PYC_OBJS := $(addsuffix .o,$(basename $(notdir $(F2PYC_SRCS))))
F2PYC_OBJS := $(addprefix $(BIN_DIR)/,$(F2PYC_OBJS))


# SRCS lists the source (Fortran) files for the HLSVD code.
# OBJS are the compiled versions of these files that land in the BIN_DIR
SRCS := _cpropack-f2pywrappers.f _cpropackmodule.c fortranobject.c \
        caprod.F cblasext.F cgemm_ovwr.F cgetu0.F clanbpro.F \
		clansvd.F clansvd_aprod.F clansvd_irl.F clansvd_irl_aprod.F \
		cmgs.pentium.F creorth.F critzvec.F csafescal.F printstat.F \
		sblasext.F sbsvd.F second.F sgemm_ovwr.F 

OBJS := $(addprefix $(BIN_DIR)/, $(addsuffix .o,$(basename $(SRCS))))


$(TARGET_LIB_NAME): $(BIN_DIR) $(OBJS) $(LAPACK_OBJS) 
	gfortran -dynamiclib -lgfortran 							\
			-static-libgfortran 								\
			-static-libgcc										\
			-L$(LIBQUADMATHA_DIR)								\
			-lquadmath 											\
			-Wall 		 										\
			-undefined dynamic_lookup 							\
			$(ARCH)												\
			-o $(TARGET_LIB_NAME)								\
			$(OBJS)												\
			$(LAPACK_OBJS)										\
			-L/Users/bsoher/miniconda2/envs/python$(PYVER2)/lib	\

# Notes on link options
# -undefined <treatment>
#   Specifies how undefined symbols are to be treated.  treatment can be: error, 
#   warning, or suppress.  Which cause the treatment of undefined  symbols  as 
#   either, errors, warnings, or suppresses the checking of undefined symbols.  
#   The default is to treat undefined symbols as errors.  When the environment 
#   variable MACOSX_DEPLOYMENT_TARGET is set to 10.3 then -undefined dynamic_lookup 
#   can also be used  to allow any undefined symbols to be looked up dynamically 
#   at runtime.  Use of a binary built with this flag requires a system with a 
#   dynamic linker from Mac OS X 10.3 or later. 


# depcheck lists the runtime libraries that the target relies on.
depcheck: $(TARGET_LIB_NAME)
	otool -L $(TARGET_LIB_NAME)


dist: $(TARGET_LIB_NAME)
	cp $(TARGET_LIB_NAME) $(DIST_TARGET_DIR)
	cp $(TARGET_LIB_NAME) $(DIST_TARGET_DIR)_osx_py$(PYVER2)


clean:
	rm -rf $(BIN_DIR)

force:
