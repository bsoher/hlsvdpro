# Python modules
from __future__ import division
import pdb

# 3rd party modules
import numpy as np
import scipy

# Our modules
import aprodw
import zreorth


KAPPA = 0.717

USE_FORTRAN_RANDOMS = False


def _get_predictable_randoms(size):
    """Given an array size, reads from the file first_random.txt and turns 
    the values therein into a complex array of length size. The array is 
    returned.
    """
    lines = open('first_random.txt').read().split('\n')
    lines = [ 'complex' + line for line in lines]
    lines = map(eval, lines)
    lines = lines[:size]
    
    return np.array(lines)
 

#  subroutine zgetu0w(transa, ndp, m, n, j, ntry, u0, u0norm, U, ldu,
# c      ierr, icgs, anormest, work,lambda,trlambda,planF,planB)

# u0norm, anormest, and ierr are returned 
# u0 (a vector) is altered



# Variable name translations 
# Fortran    Python             Description
# -------    ------             -------------------------------------------
# icgs       classical_gs       > 0 or True ==> use classical Gram-Schmidt,
#                               otherwise use modified Gram-Schmidt. No 
#                               relation to Mason Williams' Classical Gas.



def zgetu0w(transa, ndp, m, n, j, ntry, u0, uuu, classical_gs, lambda_, 
            trlambda):
# c
# c Modified by Nicola Mastronardi
# c
# c     %-----------%
# c     | Arguments |
# c     %-----------%
#       implicit none
#       include 'stat.h'
#       character*1 transa
#       integer m, n, j, i, ntry, ldu, ierr,icgs,ndp
#       integer planF,planB
#       double precision u0norm,anormest
      
# ccc      double precision u0(*),U(*),work(*)
# ccc      external aprod      
#       double complex  u0(*),U(*),work(*),lambda(*),
#      c                trlambda(*) 


# c     %------------%
# c     | Parameters |
# c     %------------%
#       integer MGS
#       double precision kappa
#       parameter(kappa = 0.717,MGS=1)

# c     %-----------------%
# c     | Local variables |
# c     %-----------------%
#       integer itry,idist,iseed(4),rsize,usize,index(3)
#       double precision nrm
#       real t1,t2,t3

# c     %--------------------%
# c     | External Functions |
# c     %--------------------%
#       logical lsame
#       double precision dznrm2
#       external dznrm2,lsame
#       external aprodw
# c-------------------- Here begins executable code ---------------------
#       call second(t1)
#       iseed(1) = 1
#       iseed(2) = 3
#       iseed(3) = 5
#       iseed(4) = 7
# c      iseed(3) = 11
# c      iseed(4) = 7
#       if (lsame(transa,'n')) then
    transa = transa.lower()
    if transa == 'n':
# c     %-------------------------%
# c     | u0 is to be an m-vector |
# c     %-------------------------%
#          rsize = n
#          usize = m
        rsize = n
        usize = m
#       else
    else:
# c     %-------------------------%
# c     | u0 is to be an n-vector |
# c     %-------------------------%
#          rsize = m
#          usize = n
        rsize = m
        usize = n
#       endif

#   idist = 2
#   ierr = 0
    # PS idist == 2 implies uniform distribution when generating random numbers. 
    ierr = 0

    zwork1 = np.zeros( (ndp, ), np.complex128)

    zwork2 = np.zeros( (ndp, ), np.complex128)

    set_ierr = True
#   do itry=1,ntry
    for itry in range(ntry):
        # PS Here we want to generate some random numbers. The random numbers 
        # generated by the Fortran code are random, but predictably so. The 
        # RNG is passed a seed that's limited to one of a few primes. As a 
        # result, it always generates the same sets of random numbers. I 
        # don't know why it's coded this way.
        # For debugging, I wrote the first set of random numbers to disk in 
        # the file first_random.txt, and if I want my Python code to use the
        # same exact set of "random" numbers I set USE_FORTRAN_RANDOMS to
        # True.
        # In practice, I leave that flag False. That makes the code faster and
        # maybe more robust.

#       call zlarnv(idist, iseed, rsize, work)   ! work of size rsize

        if USE_FORTRAN_RANDOMS:
            zworkr = _get_predictable_randoms(rsize)
        else:
            reals = np.random.uniform(-1.0, 1.0, rsize)
            imags = np.random.uniform(-1.0, 1.0, rsize)
            zworkr = np.array( [complex(r, i) for r, i in zip(reals, imags)] )

#       nrm = dznrm2(rsize,work,1)
#       DZNRM2 returns the euclidean norm, hopefully this scipy call does
#       the same.
        # for i, value in enumerate(zworkr):
        #     print "zwork[{}] = {}".format(i + 1, value)

        nrm = scipy.linalg.norm(zworkr)

        # print "zgetu0w: nrm = {}".format(nrm)

#       call second(t2)

#       call aprodw(transa,ndp,m,n,work,u0,work(ndp+1),
#   c               work(2*ndp+1),lambda,trlambda,planF,planB)

        #print "zworkr.shape = {}".format(zworkr.shape)

        zworkr, u0, zwork1, zwork2 = aprodw.aprodw(transa, ndp, m, n, 
                                                   zworkr, u0, zwork1, zwork2,
                                                   lambda_, trlambda)

        # print "zgetu0w: after aprodw"
        # for ips, value in enumerate(u0):
        #     print "u0[{}] = {}".format(ips + 1, value)

        # for i in range(len(zworkr)):
        #     print "(z) zworkr[{}] = {:.17G}".format(i + 1, zworkr[i])

        # for i in range(usize):
        #     print "(y) u0[{}] = {:.17G}".format(i + 1, u0[i])

        # for i in range(len(zwork1)):
        #     print "(z1) zwork1[{}] = {:.17G}".format(i + 1, zwork1[i])

        # for i in range(len(zwork2)):
        #     print "(y1) zwork2[{}] = {:.17G}".format(i + 1, zwork2[i])

# c   ! work of size 3*ndp

#       call second(t3)
#       tmvopx = tmvopx + (t3-t2)
#       nopx = nopx+1

#       u0norm = dznrm2(usize,u0,1)
#       DZNRM2 returns the Euclidean norm, hopefully this scipy call does
#       the same.
        u0norm = scipy.linalg.norm(u0)

#       anormest = u0norm/nrm
        anormest = u0norm / nrm

        # print "zgetu0w: u0norm = {}, anormest = {}".format(u0norm, anormest)

#       index(1) = 1
#       index(2) = j
#       index(3) = j+1

        index = [1, j, j + 1]

        # PS - MGS and icgs both refer to the same thing. zreorth() can perform
        # classical or modified Gram-Schmidt orthogonalization. In some version
        # of the Fortran code, this was controlled by MGS, but that's commented
        # out in the version of the code we have. 
        # Instead, its controlled by icgs. 
        # icgs ==> non-zero (True) to tell zreorth to use classical Gram-Schmidt,
        #          False to use modified Gram-Schmidt.
        # In the version of the code we have, it's hardcoded to 1 so we always
        # use classical Gram-Schmidt.

# c         if  (MGS.eq.0) then
#             call zreorth(usize,j,U,ldu,u0,u0norm,index,kappa,work,
#      c           icgs)
        u0, u0norm = zreorth.zreorth(usize, j, uuu, u0, u0norm, index, 
                                     KAPPA, classical_gs)
        # for ips, value in enumerate(u0):
        #     print "u0[{}] = {}".format(ips + 1, value)

        # print "u0norm = {}".format(u0norm)
        # print "stifle!"        

# c         else
# c            call zreorth2(usize,j,U,ldu,u0,u0norm,index)
# c         endif
#          if (u0norm.gt.0) goto 9999

        if u0norm > 0:
            set_ierr = False
            break

#       enddo
#       ierr = -1
    if set_ierr:
        ierr = -1
        
#  9999 call second(t2)
#       tgetu0 = tgetu0 + (t2-t1)
#       return
#       end
      
    return u0norm, anormest, ierr
